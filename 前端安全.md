# 前端安全
## 如何防止 xss 攻击
1. 通常页面中包含的用户输入内容都在`固定的容器或者属性`内，以文本的形式展示。
2. 攻击者利用这些页面的用户输入片段，拼接特殊格式的字符串，突破原有位置的限制，形成了代码片段。
3. 攻击者通过在`目标网站`上注入脚本，使之在用户的浏览器上运行，从而引发潜在风险。
4. 通过 `HTML 转义`，可以防止 XSS 攻击

(1) 做了 HTML 转义，并不等于高枕无忧。
(2) 对于链接跳转，如 
```<a href="xxx" 或 location.href="xxx"，要检验其内容，禁止以 javascript: 开头的链接，和其他非法的 scheme。```

## 根据上下文采用不同的转义规则
（1）像 JSON 字符的转义，当遇到特定字符把其作为 JavaScript 字面量使用时会抛出语法错误
（2）JSON 中包含字符串 `</script>` 时，当前的 script 标签将会被闭合，后面的字符串内容浏览器会按照 HTML 进行解析；通过增加下一个 `<script>`标签等方法就可以完成注入。
- HTML 转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下 XSS 隐患。
- 应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。

## 漏洞总结
- 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。
- 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。
- 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。
- 在标签的 href、src 等属性中，包含 javascript: 等可执行代码。
- 在 onload、onerror、onclick 等事件中，注入不受控制代码。
- 在 style 属性和标签中，包含类似 background-image:url("javascript:..."); 的代码（新版本浏览器已经可以防范）。
- 在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）。

## XSS 攻击分类
攻击者通过在目标网站上注入`恶意脚本`，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的`敏感信息`如 Cookie、SessionID 等，进而危害数据安全。

### 存储型 XSS
攻击者将恶意代码提交到目标网站的`数据库`中

这种攻击常见于带有用户保存数据的网站功能，如`论坛发帖、商品评论、用户私信等`。
### 反射性 XSS
- 攻击者构造出特殊的 URL，其中包含恶意代码
- 用户打开目标网站时，网站服务端将恶意代码从`数据库`取出，`拼接`在 HTML 中返回给浏览器。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

### DOM 型 XSS
攻击者构造出特殊的 URL，其中包含恶意代码。

用户浏览器接收到响应后`解析执行`，前端 JavaScript 取出 URL 中的恶意代码并执行。


- DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

### XSS 攻击的预防
1. 攻击者提交恶意代码。
2. 浏览器执行恶意代码。

首先是能否在用户输入的过程中过滤掉用户的恶意代码？

**输入过滤**

在用户提交时，由前端过滤输入，然后提交到后端。这样做是否可行呢？

那么，换一个过滤时机：后端在写入数据库前，对输入进行过滤，然后把“安全的”内容，返回给前端。这样是否可行呢？

答案是不可行。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。

不可行，例如 `5 < 7` 转义后变成了 `5 &lt 7`

问题是：在提交阶段，我们并不确定内容要输出到哪里。

这里的“并不确定内容要输出到哪里”有两层含义：

1. 用户的输入内容可能同时提供给前端和客户端，而一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 &lt; 7 )。
2. 在前端中，不同的位置所需的编码也不同。

- 当 5 &lt; 7 作为 HTML 拼接页面时，可以正常显示：

- 当 5 &lt; 7 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等。

所以，输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。

当然，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。

既然输入过滤并非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS。这部分分为两类：

防止 HTML 中出现注入。
防止 JavaScript 执行时，执行恶意代码。

### 预防存储型和反射型 XSS 攻击
存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。

预防这两种漏洞，有两种常见做法：

- 改成纯前端渲染，把代码和数据分隔开。
- 对 HTML 做充分转义。
### 纯前端渲染
纯前端渲染的过程：

1. 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
2. 然后浏览器执行 HTML 中的 JavaScript。
3. JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。
4. 
在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。

但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 onload 事件和 href 中的 javascript:xxx 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。

在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。
转义 HTML

### 预防 DOM 型 XSS 攻击
1. 使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。
2. 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。
3. DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，`<a>` 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。

### 其他 XSS 防范措施
（1）**Content Security Policy**

严格的 CSP 在 XSS 的防范中可以起到以下的作用：
1. 禁止加载外域代码，防止复杂的攻击逻辑。
2. 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
3. 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
4. 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
5. 合理使用上报可以及时发现 XSS，利于尽快修复问题。

（2）**输入内容长度控制**

对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。

（3）**其他安全措施**

- HTTP-only Cookie: `禁止 JavaScript 读取某些敏感 Cookie`，攻击者完成 XSS 注入后也无法窃取此 Cookie。

- 验证码：防止脚本冒充用户提交危险操作。

## XSS 攻击的总结
虽然很难通过技术手段完全避免 XSS，但我们可以总结以下原则减少漏洞的产生：

- 利用模板引擎
开启模板引擎自带的 HTML 转义功能。例如：
在 ejs 中，尽量使用 <%= data %> 而不是 <%- data %>；
在 doT.js 中，尽量使用 {{! data } 而不是 {{= data }；
在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。
- 避免内联事件
尽量不要使用 onLoad="onload('{{data}}')"、onClick="go('{{action}}')" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。
- 避免拼接 HTML
前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。
- 时刻保持警惕
在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。
- 增加攻击难度，降低攻击后果
通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。
- 主动检测和发现
可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。


## 如何防止 CSRF
攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的`注册凭证`，绕过后台的用户验证，达到`冒充用户`对被攻击的网站执行某项操作的目的。

csrf 两大特点：
1. CSRF（通常）发生在第三方域名。
2. CSRF攻击者不能获取到Cookie等信息，只是使用。

针对这两点，我们可以专门制定防护策略，如下：
- 阻止不明外域的访问
- - 同源检测
- - Samesite Cookie
- 提交时要求附加本域才能获取的信息
- - CSRF Token
- - 双重Cookie验证

### 同源检测
在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：
- Origin Header
- Referer Header

(1) 使用 Origin Header 确定来源域名
但是Origin在以下两种情况下并不存在：
1. IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头
2. 302重定向：在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。

(2) 使用Referer Header确定来源域名
根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。

但是即使存在这么多策略，攻击者依然可以在自己的请求中`隐藏 Referer`

另外，前面说过，CSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。

综上所述：`同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击`。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对`关键的接口做额外的防护措施`。

### CSRF TOKEN
CSRF Token的防护策略分为三个步骤：
1. 将CSRF Token输出到页面中

首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的`Session`中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的`a和form标签后加入Token`。这样可以解决大部分的请求，但是对于在页面`加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token`。

2. 页面提交的请求携带这个Token

对于GET请求，Token将附在请求地址之后，这样URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上：
``` js
  <input type="hidden" name="csrftoken" value="tokenvalue"/>
```

3. 服务器验证Token是否正确

当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。

### 双重Cookie验证
在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。

由于任何跨域都会导致前端无法获取Cookie中的字段（包括子域名之间），于是发生了如下情况：

- 如果用户访问的网站为www.a.com，而后端的api域名为api.a.com。那么在www.a.com下，前端拿不到api.a.com的Cookie，也就无法完成双重Cookie认证。
- 于是这个认证Cookie必须被种在a.com下，这样每个子域都可以访问。
- 任何一个子域都可以修改a.com下的Cookie。
- 某个子域名存在漏洞被XSS攻击（例如upload.a.com）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了a.com下的Cookie。
- 攻击者可以直接使用自己配置的Cookie，对XSS中招的用户再向www.a.com下，发起CSRF攻击。

**总结 **

用双重Cookie防御CSRF的优点：
- 无需使用Session，适用面更广，易于实施。
- Token储存于客户端中，不会给服务器带来压力。
- 相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。

缺点：
- Cookie中增加了额外的字段。
- 如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。
- 难以做到子域名的隔离。
- 为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。

### Samesite Cookie属性
Samesite=Strict 这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。

如果SamesiteCookie被设置为Strict，浏览器在任何跨域请求中都不会携带Cookie，新标签重新打开也不携带，所以说CSRF攻击基本没有机会。

但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的Cookie都不会存在。尤其是有登录的网站，那么我们`新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录`。对于用户来讲，可能体验不会很好。

Samesite=Lax 这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie。

当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的`异步请求`，或者页面跳转是通过`表单的 post` 提交触发的，则bar也不会发送。

如果SamesiteCookie被设置为Lax，那么其他网站通过`页面跳转`过来的时候可以使用Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。

### 防止网站被利用
CSRF的攻击可以来自：
- 攻击者自己的网站。
- 有文件上传漏洞的网站。
- 第三方论坛等用户内容。
- 被攻击网站自己的评论功能等。

对于来自黑客自己的网站，我们无法防护。但对其他情况，那么如何防止自己的网站被利用成为攻击的源头呢？

- 严格管理所有的上传接口，防止任何预期之外的上传内容（例如HTML）。
- 添加Header X-Content-Type-Options: nosniff 防止黑客上传HTML内容的资源（例如图片）被解析为网页。
- 对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。
- 当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。

## 总结
- CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。
- CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。
- 保证页面的幂等性，后端接口不要在GET页面中做用户操作。


## Cookie Session Token JWT
cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。

### cookie 重要的属性
|  属性   | 说明  |
|  ----  | ----  |
| name=value  | 键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型，如果值为 Unicode 字符，需要为字符编码。如果值为二进制数据，则需要使用 BASE64 编码。 |
| domain  | 	指定 cookie 所属域名，默认是当前域名 |
| path  | 	指定 cookie 在哪个路径（路由）下生效，默认是 '/'。如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read。 |
| maxAge  | 	cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。- 比 expires 好用。 |
| expires  | 	过期时间，在设置的某个时间点后该 cookie 就会失效。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除 |
| secure  | 	该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。 |
| httpOnly  | 	如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全 |


### JWT
header payload Signature

使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。
``` js
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，就可以返回给用户。

#### JWT 使用方式

1. 存储在 cookie 或者 localStorage里，可以通过 cookie 自动发送，但是不能跨域
2. Http 请求头部的 Authorization 字段里面
3. 另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。

#### JWT 的几个特点
（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。

（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。

（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。

（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。

（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。

（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。

### 单点登录
当我们业务线越来越多，就会有更多业务系统分散到不同域名下，就需要`「一次登录，全线通用」`的能力，叫做「单点登录」

“虚假”的单点登录（主域名相同），如果业务都在同一主域名下，比如 wenku.baidu.com 或者 tieba.baidu.com，直接把 cookie domain 设置成 baidu.com

“真实”的单点登录（主域名不同）

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5a94e9c990d4d69a4a0845c4f8dc6a1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

因为 cookie，localStorage 等方式都是有域限制，这意味着登录状态需要在 SSO 统一验证，但签发地是不同服务器。

举例 SSO 是公司身份认证的地方，A,B,C 是三个不同的项目。为了在 A 项目获得登录态，需要首先跳转到 SSO 进行身份认证。SSO 认证之后会把项目地址和一次性的身份凭证交给你，并且告诉你要去哪个部门兑换身份卡。`（URL（项目地址），code（一次性凭证），callback（哪个部门））`。于是按照规则去办理身份卡，项目 A 跟公司身份认证的地方能通信，带着这些信息能够证实我确实就是这个人，并且项目A也开了一个身份卡给我们，这个身份卡放在 cookie 每次访问携带，以此完成登录认证。其他项目也如此

### 参考
- [前端安全系列（一）：如何防止XSS攻击？](https://juejin.cn/post/6844903685122703367)
- [前端安全系列（二）：如何防止CSRF攻击？](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)
- [前端鉴权的兄弟们：cookie、session、token、jwt、单点登录](https://juejin.cn/post/6898630134530752520)
- [JSON Web Token 入门教程](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)